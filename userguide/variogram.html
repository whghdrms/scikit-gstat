
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Variography &#8212; SciKit GStat 0.3.2 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Interpolation" href="kriging.html" />
    <link rel="prev" title="Introduction" href="introduction.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="variography">
<h1>Variography<a class="headerlink" href="#variography" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-variogram">
<h2>The variogram<a class="headerlink" href="#the-variogram" title="Permalink to this headline">¶</a></h2>
<div class="section" id="general">
<h3>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h3>
<p>We start by constructing a random field and sample it. Without knowing about
random field generators, an easy way to go is to stick two trigonometric
functions together and add some noise. There should be clear spatial
correlation apparent.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="gp">In [3]: </span><span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;ggplot&#39;</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
</pre></div>
</div>
<p>This field could look like</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># apply the function to a meshgrid and add noise</span>
<span class="gp">In [5]: </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">500</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span><span class="mi">500</span><span class="n">j</span><span class="p">]</span>

<span class="gp">In [6]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="go"># generate a regular field</span>
<span class="gp">In [7]: </span><span class="n">_field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">10</span>

<span class="go"># add noise</span>
<span class="gp">In [8]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="gp">In [9]: </span><span class="n">z</span> <span class="o">=</span> <span class="n">_field</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span>  <span class="mi">500</span><span class="p">))</span>

<span class="gp">In [10]: </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdYlBu_r&#39;</span><span class="p">)</span>
<span class="gh">Out[10]: </span><span class="go">&lt;matplotlib.image.AxesImage at 0x7febfc09e828&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/tf.png"><img alt="../_images/tf.png" src="../_images/tf.png" style="width: 8in;" /></a>
<div class="section" id="using-scikit-gstat">
<h4>Using scikit-gstat<a class="headerlink" href="#using-scikit-gstat" title="Permalink to this headline">¶</a></h4>
<p>It’s now easy and straightforward to calculate a variogram using
<code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code>. We need to sample the field and pass the coordinates and
value to the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [11]: </span><span class="kn">from</span> <span class="nn">skgstat</span> <span class="kn">import</span> <span class="n">Variogram</span>

<span class="go"># random coordinates</span>
<span class="gp">In [12]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="gp">In [13]: </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="gp">In [14]: </span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">((</span><span class="n">z</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="gp">In [15]: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Variogram</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gh">Out[16]: </span><span class="go">&lt;Figure size 800x500 with 2 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/var1.png"><img alt="../_images/var1.png" src="../_images/var1.png" style="width: 8in;" /></a>
<p>From my personal point of view, there are three main issues with this approach:</p>
<ul class="simple">
<li><p>If one is not an geostatistics expert, one has no idea what he actually did
and can see in the presented figure.</p></li>
<li><p>The figure includes an spatial model, one has no idea if this model is
suitable and fits the observations (wherever they are in the figure)
sufficiently.</p></li>
<li><p>Refer to the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.__init__" title="skgstat.Variogram.__init__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__init__</span></code></a> method of the
Variogram class. There are 10+ arguments that can be set optionally. The
default values will most likely not fit your data and requirements.</p></li>
</ul>
<p>Therefore one will have to understand how the
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> works along with some basic
knowledge about variography in oder to be able to properly use <code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code>.</p>
<p>However, what we can discuss from the figure, is what a variogram actually is
At its core it relates a dependent variable to an independent variable and,
in a second step, tries to describe this relationship with a statistical
model. This model on its own describes some of the spatial properties of the
random field and can further be utilized in an interpolation to select nearby
points and weight them based on their statistical properties.</p>
<p>The variogram relates the separating distance between two observation points
to a measure of variability of values at that given distance. Our expectation
is that variance is increasing with distance, what can basically be seen in
the presented figure.</p>
</div>
</div>
<div class="section" id="distance">
<h3>Distance<a class="headerlink" href="#distance" title="Permalink to this headline">¶</a></h3>
<p>Consider the variogram figure from above, with which an <em>independent</em> and
<em>dependent</em> variable was introduced. In statistics it is common to use
<em>dependent</em> variable as an alias for <em>target variable</em>, because its value is
dependent on the state of the independent variable. In the case of a
variogram, this is the metric of variance on the y-axis. The independent
variable is a measure of (usually) Euclidean distance.</p>
<p>Consider observations taken in the environment, it is fairly unlikely to find
two pairs of observations where the separating distance between the
coordinates match exactly the same value. Therefore it is useful to group all
point pairs at the same distance <em>lag</em> together into one group, or <em>bin</em>.
Beside practicability, there is also another reason, why one would want to
group point pairs at similar separating distances together into one bin.
This becomes obvious, when one plots the difference in value over the
distance for all point pair combinations that can be formed for a given sample.
The <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> has a function for that:
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.distance_difference_plot" title="skgstat.Variogram.distance_difference_plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">distance_difference_plot</span></code></a>:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [17]: </span><span class="n">V</span><span class="o">.</span><span class="n">distance_difference_plot</span><span class="p">()</span>
<span class="gh">Out[17]: </span><span class="go">&lt;Figure size 800x600 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/dist_diff_plot.png"><img alt="../_images/dist_diff_plot.png" src="../_images/dist_diff_plot.png" style="width: 8in;" /></a>
<p>While it is possible to see the increasing variability with increasing
distance here quite nicely, it is not possible to guess meaningful moments
for the distributions within the bins. Last but not least, to derive a simple
model as presented in the variogram figure above by the green line, we have
to be able to compress all values at a given distance lag to one estimation
of variance. This would not be possible from the the figure above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are also procedures that can fit a model directly based on unbinned
data. As none of these methods is implemented into <code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code>, they
will not be discussed here. If you need them, you are more than welcome
to implement them. Else you’ll have to wait until I did that.</p>
</div>
<p>Binning the separating distances into distance lags is therefore a crucial and
most important task in variogram analysis. The final binning must
discretizise the distance lag at a meaningful resolution at the scale of
interest while still holding enough members in the bin to make valid
estimations. Often this is a trade-off relationship and one has to find a
suitable compromise.</p>
<p>Before diving into binning, we have to understand how the
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> handles distance data. The
distance calculation can be controlled by the
<code class="xref py py-func docutils literal notranslate"><span class="pre">dist_func</span></code> argument, which
takes either a string or a function. The default value is <cite>‘euclidean’</cite>.
This value is directly passed down to the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html#scipy.spatial.distance.pdist" title="(in SciPy v1.6.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdist</span></code></a> as the <cite>metric</cite> argument.
Consequently, the distance data is stores as a distance matrix for all
input locations passed to <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> on
instantiation. To be more precise, only the upper triangle is stored
in an <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code></a> with the distance values sorted
row-wise. Consider this very straightforward set of locations:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [18]: </span><span class="n">locations</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>

<span class="gp">In [19]: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Variogram</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="gp">In [20]: </span><span class="n">V</span><span class="o">.</span><span class="n">distance</span>
<span class="gh">Out[20]: </span><span class="go">array([1.   , 1.414, 1.   , 1.   , 1.414, 1.   ])</span>

<span class="go"># turn into a 2D matrix again</span>
<span class="gp">In [21]: </span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span>

<span class="gp">In [22]: </span><span class="nb">print</span><span class="p">(</span><span class="n">squareform</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">distance</span><span class="p">))</span>
<span class="go">[[0.    1.    1.414 1.   ]</span>
<span class="go"> [1.    0.    1.    1.414]</span>
<span class="go"> [1.414 1.    0.    1.   ]</span>
<span class="go"> [1.    1.414 1.    0.   ]]</span>
</pre></div>
</div>
</div>
<div class="section" id="binning">
<h3>Binning<a class="headerlink" href="#binning" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, in real world observation data, there will hardly
be two observation location pairs at <em>exactly</em> the same distance.
Thus, we need to group information about point pairs at <em>similar</em> distance
together, to learn how similar their observed values are.
With a <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a>, we will basically try
to find and describe some systematic statistical behavior from these
similarities. The process of grouping distance data together is
called binning.</p>
<p><code class="docutils literal notranslate"><span class="pre">scikit-gstat</span></code> has two different methods for binning distance data.
They can be set using the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.bin_func" title="skgstat.Variogram.bin_func"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin_func</span></code></a>
attribute. You have to pass the name of the method.
This has to be one of <code class="docutils literal notranslate"><span class="pre">['even',</span> <span class="pre">'uniform]</span></code> to use one of the predefined
binning functions. Both methods will use two parameters to calculate the
bins from the distance matrix: <code class="docutils literal notranslate"><span class="pre">n</span></code>, the amount of bins,
and <code class="docutils literal notranslate"><span class="pre">maxlag</span></code>, the maximum distance lag to be considered. You can choose
both parameters during Variogram instantiation as
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.n_lags" title="skgstat.Variogram.n_lags"><code class="xref py py-func docutils literal notranslate"><span class="pre">n_lags</span></code></a> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">maxlag</span></code>. The <code class="docutils literal notranslate"><span class="pre">'even'</span></code> method will
then form <code class="docutils literal notranslate"><span class="pre">n</span></code> bins from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">maxlag</span></code> of same width.
The <code class="docutils literal notranslate"><span class="pre">'uniform'</span></code> method will form <code class="docutils literal notranslate"><span class="pre">n</span></code> bins from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">maxlag</span></code>
with the same value count in each bin.
The following example should illustrate this:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [23]: </span><span class="kn">from</span> <span class="nn">skgstat.binning</span> <span class="kn">import</span> <span class="n">even_width_lags</span><span class="p">,</span> <span class="n">uniform_count_lags</span>

<span class="gp">In [24]: </span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">pdist</span>

<span class="gp">In [25]: </span><span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="gp">In [26]: </span><span class="n">distances</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, look at the different bin edges for the calculated dummy
distance matrix:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [27]: </span><span class="n">even_width_lags</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="gh">Out[27]: </span><span class="go"></span>
<span class="go">array([ 4.405,  8.809, 13.214, 17.618, 22.023, 26.427, 30.832, 35.237,</span>
<span class="go">       39.641, 44.046])</span>

<span class="gp">In [28]: </span><span class="n">uniform_count_lags</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="gh">Out[28]: </span><span class="go"></span>
<span class="go">array([ 7.198, 10.432, 12.34 , 15.147, 17.693, 20.381, 23.013, 26.278,</span>
<span class="go">       30.641, 44.046])</span>
</pre></div>
</div>
</div>
<div class="section" id="observation-differences">
<h3>Observation differences<a class="headerlink" href="#observation-differences" title="Permalink to this headline">¶</a></h3>
<p>By the term <em>observation differences</em>, the distance between the
observed values are meant. As already layed out, the main idea of
a variogram is to systematially relate similarity of observations
to their spatial proximity. The spatial part was covered in the
sections above, finalized with the calculation of a suitable
binning of all distances. We want to relate exactly these bins
to a measure of similarity of all observation point pairs that
fall into this bin.</p>
<p>That’s basically it. We need to do three more steps to come up
with <em>one</em> value per bin, statistically describing the similarity
at that distance.</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Find all point pairs that fall into a bin</p></li>
<li><p>Calculate the <em>distance</em> (difference) of the observed values</p></li>
<li><p>Describe all differences by one number</p></li>
</ol>
</div></blockquote>
<p>Finding all pairs within a bin is straightforward. We already have
the bin edges and all distances between all possible observation
point combinations (stored in the distance matrix). Using the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.squareform.html#scipy.spatial.distance.squareform" title="(in SciPy v1.6.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">squareform</span></code></a> function
of scipy, we <em>could</em> turn the distance matrix into a 2D version.
Then the row and column indices align with the values indices.
However, the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> implements
a method for doing mapping a bit more efficiently.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As of this writing, the actual iterator that yields the group
number for each point is written in a plain Python loop.
This is not very fast and in fact the main bottleneck of this class.
I am evaluating numba, cython or a numpy based solution at the moment
to gain better performance.</p>
</div>
<p>A <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.20)"><code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code></a> of bin groups for each point pair that
is indexed exactly like the <code class="xref py py-func docutils literal notranslate"><span class="pre">distance</span> <span class="pre">&lt;skgstat.Variogram.distance()</span></code>
array can be obtained by <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_groups" title="skgstat.Variogram.lag_groups"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_groups</span></code></a>.</p>
<p>This will be illustrated by some sample data (you can find the CSV file
in the github repository of SciKit-GStat).
You can easily read the data using pandas.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [29]: </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="gp">In [30]: </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data/sample_sr.csv&#39;</span><span class="p">)</span>

<span class="gp">In [31]: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Variogram</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)),</span> <span class="n">data</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
<span class="gp">   ....: </span>    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_lags</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [32]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="gh">Out[32]: </span><span class="go">&lt;Figure size 800x500 with 2 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/variogram_sample_data.png"><img alt="../_images/variogram_sample_data.png" src="../_images/variogram_sample_data.png" style="width: 8in;" /></a>
<p>Then, you can compare the first 10 point pairs from the distance matrix
to the first 10 elements returned by the
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_groups" title="skgstat.Variogram.lag_groups"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_groups</span> <span class="pre">function</span></code></a>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="go"># first 10 distances</span>
<span class="gp">In [33]: </span><span class="n">V</span><span class="o">.</span><span class="n">distance</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>
<span class="gh">Out[33]: </span><span class="go"></span>
<span class="go">array([20.809, 51.478, 27.203, 44.721, 91.608, 71.784, 87.693, 85.446,</span>
<span class="go">       18.788, 23.195])</span>

<span class="go"># first 10 groups</span>
<span class="gp">In [34]: </span><span class="n">V</span><span class="o">.</span><span class="n">lag_groups</span><span class="p">()[:</span><span class="mi">10</span><span class="p">]</span>
<span class="gh">Out[34]: </span><span class="go">array([ 8, 21, 11, 18, -1, -1, -1, -1,  7,  9])</span>
</pre></div>
</div>
<p>Now, we need the actual <code class="xref py py-func docutils literal notranslate"><span class="pre">Variogram.bins</span></code>
to verify the grouping.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [35]: </span><span class="n">V</span><span class="o">.</span><span class="n">bins</span>
<span class="gh">Out[35]: </span><span class="go"></span>
<span class="go">array([ 2.4,  4.8,  7.2,  9.6, 12. , 14.4, 16.8, 19.2, 21.6, 24. , 26.4,</span>
<span class="go">       28.8, 31.2, 33.6, 36. , 38.4, 40.8, 43.2, 45.6, 48. , 50.4, 52.8,</span>
<span class="go">       55.2, 57.6, 60. ])</span>
</pre></div>
</div>
<p>The first and 9th element are grouped into group <code class="docutils literal notranslate"><span class="pre">3</span></code>. Their values are
<code class="docutils literal notranslate"><span class="pre">20.8</span></code> and <code class="docutils literal notranslate"><span class="pre">18.8</span></code>. The grouping starts with <code class="docutils literal notranslate"><span class="pre">0</span></code>, therefore the
corresponding upper bound of the bin is at index <code class="docutils literal notranslate"><span class="pre">3</span></code> and the lower at
<code class="docutils literal notranslate"><span class="pre">2</span></code>. The bin edges are therefore <code class="docutils literal notranslate"><span class="pre">15.8</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">21.07</span></code>.
Consequently, the binning and grouping worked fine.</p>
<p>If you want to access all value pairs at a given group, it would of
course be possible to use the machanism above to find the correct points.
However, <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">class</span></code></a> offers an iterator
that already does that for you:
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_classes" title="skgstat.Variogram.lag_classes"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_classes</span></code></a>. This iterator
will yield all pair-wise observation value differences for the bin
of the actual iteration. The first iteration (index = 0, if you wish)
will yield all differences of group id <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_classes" title="skgstat.Variogram.lag_classes"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_classes</span></code></a> will yield
the difference in value of observation point pairs, not the pairs
themselves.</p>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [36]: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">lag_classes</span><span class="p">()):</span>
<span class="gp">   ....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[Group </span><span class="si">%d</span><span class="s1">]: </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">group</span><span class="p">)))</span>
<span class="gp">   ....: </span>
<span class="go">[Group 0]: 0.27</span>
<span class="go">[Group 1]: 0.43</span>
<span class="go">[Group 2]: 0.65</span>
<span class="go">[Group 3]: 0.80</span>
<span class="go">[Group 4]: 0.84</span>
<span class="go">[Group 5]: 1.00</span>
<span class="go">[Group 6]: 1.11</span>
<span class="go">[Group 7]: 1.14</span>
<span class="go">[Group 8]: 1.10</span>
<span class="go">[Group 9]: 1.11</span>
<span class="go">[Group 10]: 1.13</span>
<span class="go">[Group 11]: 1.15</span>
<span class="go">[Group 12]: 1.12</span>
<span class="go">[Group 13]: 1.14</span>
<span class="go">[Group 14]: 1.18</span>
<span class="go">[Group 15]: 1.25</span>
<span class="go">[Group 16]: 1.23</span>
<span class="go">[Group 17]: 1.24</span>
<span class="go">[Group 18]: 1.31</span>
<span class="go">[Group 19]: 1.38</span>
<span class="go">[Group 20]: 1.33</span>
<span class="go">[Group 21]: 1.29</span>
<span class="go">[Group 22]: 1.27</span>
<span class="go">[Group 23]: 1.31</span>
<span class="go">[Group 24]: 1.32</span>
</pre></div>
</div>
<p>The only thing that is missing for a variogram is that we will not
use the arithmetic mean to describe the realtionship.</p>
</div>
<div class="section" id="experimental-variograms">
<h3>Experimental variograms<a class="headerlink" href="#experimental-variograms" title="Permalink to this headline">¶</a></h3>
<p>The last stage before a variogram function can be modeled is to define
an empirical variogram, also known as <em>experimental variogram</em>, which
will be used to parameterize a variogram model.
However, the expermental variogram already contains a lot of information
about spatial relationships in the data. Therefore, it’s worth looking
at more closely. Last but not least a poor expermental variogram will
also affect the variogram model, which is ultimatively used to interpolate
the input data.</p>
<p>The previous sections summarized how distance is calculated and handeled
by the <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">class</span></code></a>.
The <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram.lag_groups" title="skgstat.Variogram.lag_groups"><code class="xref py py-func docutils literal notranslate"><span class="pre">lag_groups</span> <span class="pre">function</span></code></a> makes it
possible to find corresponding observation value pairs for all distance
lags. Finally the last step will be to use a more suitable estimator
for the similarity of observation values at a specific lag.
In geostatistics this estimator is called semi-variance and the
the most popular estimator is called <em>Matheron estimator</em>.
In case the estimator used is not further specified, Matheron was used.
It is defined as</p>
<div class="math notranslate nohighlight">
\[\gamma (h) = \frac{1}{2N(h)} * \sum_{i=1}^{N(h)}(x)^2\]</div>
<p>with:</p>
<div class="math notranslate nohighlight">
\[x = Z(x_i) - Z(x_{i+h})\]</div>
<p>where <span class="math notranslate nohighlight">\(Z(x_i)\)</span> is the observation value at the i-th location
<span class="math notranslate nohighlight">\(x_i\)</span>. <span class="math notranslate nohighlight">\(h\)</span> is the distance lag and <span class="math notranslate nohighlight">\(N(h)\)</span> is the
number of point pairs at that lag.</p>
<p>You will find more estimators in <code class="xref py py-mod docutils literal notranslate"><span class="pre">skgstat.estimators</span></code>.
There is the <a class="reference internal" href="../reference/estimator.html#skgstat.estimators.cressie" title="skgstat.estimators.cressie"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cressie-Hawkins</span></code></a>,
which is more robust to extreme values. Other so called robust
estimators are <a class="reference internal" href="../reference/estimator.html#skgstat.estimators.dowd" title="skgstat.estimators.dowd"><code class="xref py py-func docutils literal notranslate"><span class="pre">Dowd</span></code></a> or
<a class="reference internal" href="../reference/estimator.html#skgstat.estimators.genton" title="skgstat.estimators.genton"><code class="xref py py-func docutils literal notranslate"><span class="pre">Genton</span></code></a>.
The remaining are experimental estimators and should only be used
with caution.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [37]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">_a</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="gp">In [38]: </span><span class="n">axes</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="gp">In [39]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gh">Out[39]: </span><span class="go">&lt;Figure size 800x800 with 4 Axes&gt;</span>

<span class="gp">In [40]: </span><span class="n">V</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="s1">&#39;cressie&#39;</span>

<span class="gp">In [41]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gh">Out[41]: </span><span class="go">&lt;Figure size 800x800 with 4 Axes&gt;</span>

<span class="gp">In [42]: </span><span class="n">V</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="s1">&#39;dowd&#39;</span>

<span class="gp">In [43]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gh">Out[43]: </span><span class="go">&lt;Figure size 800x800 with 4 Axes&gt;</span>

<span class="gp">In [44]: </span><span class="n">V</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="s1">&#39;genton&#39;</span>

<span class="gp">In [45]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gh">Out[45]: </span><span class="go">&lt;Figure size 800x800 with 4 Axes&gt;</span>

<span class="gp">In [46]: </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/compare_estimators.png"><img alt="../_images/compare_estimators.png" src="../_images/compare_estimators.png" style="width: 8in;" /></a>
</div>
<div class="section" id="variogram-models">
<h3>Variogram models<a class="headerlink" href="#variogram-models" title="Permalink to this headline">¶</a></h3>
<p>The last step to describe the spatial pattern in a data set
using variograms is to model the empirically observed and calculated
experimental variogram with a proper mathematical function.
Technically, this setp is straightforward. We need to define a
function that takes a distance value (not a lag) and returns
a semi-variance value. One big advantage of these models is, that we
can assure different things, like positive definitenes. Most models
are also monotonically increasing and approach an upper bound.
Usually these models need three parameters to fit to the experimental
variogram. All three parameters have a meaning and are usefull
to learn something about the data. This upper bound a model approaches
is called <em>sill</em>. The distance at which 95% of the sill are approached
is called the <em>range</em>. That means, the range is the distance at which
observation values do <strong>not</strong> become more dissimilar with increasing
distance. They are statistically independent. That also means, it doesn’t
make any sense to further describe spatial relationships of observations
further apart with means of geostatistics. The last parameter is the <em>nugget</em>.
It is used to add semi-variance to all values. Graphically that means to
<em>move the variogram up on the y-axis</em>. The nugget is the semi-variance modeled
on the 0-distance lag. Compared to the sill it is the share of variance that
can not be described spatially.</p>
<div class="section" id="the-spherical-model">
<h4>The spherical model<a class="headerlink" href="#the-spherical-model" title="Permalink to this headline">¶</a></h4>
<p>The sperical model is the most commonly used variogram model.
It is characterized by a very steep, exponential increase in semi-variance.
That means it approaches the sill quite quickly. It can be used when
observations show strong dependency on short distances.
It is defined like:</p>
<div class="math notranslate nohighlight">
\[\gamma = b + C_0 * \left({1.5*\frac{h}{r} - 0.5*\frac{h}{r}^3}\right)\]</div>
<p>if h &lt; r, and</p>
<div class="math notranslate nohighlight">
\[\gamma = b + C_0\]</div>
<p>else. <code class="docutils literal notranslate"><span class="pre">b</span></code> is the nugget, :math:<code class="docutils literal notranslate"><span class="pre">C_0</span></code> is the sill, <code class="docutils literal notranslate"><span class="pre">h</span></code> is the input
distance lag and <code class="docutils literal notranslate"><span class="pre">r</span></code> is the effective range. That is the range parameter
described above, that describes the correlation length.
Many other variogram model implementations might define the range parameter,
which is a variogram parameter. This is a bit confusing, as the range parameter
is specific to the used model. Therefore I decided to directly use the
<em>effective range</em> as a parameter, as that makes more sense in my opinion.</p>
<p>As we already calculated an experimental variogram and find the spherical
model in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">skgstat.models</span></code> sub-module, we can utilize e.g.
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit" title="(in SciPy v1.6.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">curve_fit</span></code></a> from scipy to fit the model
using a least squares approach.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [47]: </span><span class="kn">from</span> <span class="nn">skgstat</span> <span class="kn">import</span> <span class="n">models</span>

<span class="go"># set estimator back</span>
<span class="gp">In [48]: </span><span class="n">V</span><span class="o">.</span><span class="n">estimator</span> <span class="o">=</span> <span class="s1">&#39;matheron&#39;</span>

<span class="gp">In [49]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;spherical&#39;</span>

<span class="gp">In [50]: </span><span class="n">xdata</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">bins</span>

<span class="gp">In [51]: </span><span class="n">ydata</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">experimental</span>

<span class="gp">In [52]: </span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

<span class="gp">In [53]: </span><span class="n">cof</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">spherical</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <em>cof</em> are now the coefficients found to fit the model to the data.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [54]: </span><span class="n">pprint</span><span class="p">(</span><span class="s2">&quot;range: </span><span class="si">%.2f</span><span class="se">\n</span><span class="s2">sill: %.f</span><span class="se">\n</span><span class="s2">nugget: </span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cof</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cof</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cof</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">&#39;range: 1.00\nsill: 102\nnugget: -100.87&#39;</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [55]: </span><span class="n">xi</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>

<span class="gp">In [56]: </span><span class="n">yi</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">spherical</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">cof</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

<span class="gp">In [57]: </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="s1">&#39;og&#39;</span><span class="p">)</span>
<span class="gh">Out[57]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7fec04b456a0&gt;]</span>

<span class="gp">In [58]: </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="s1">&#39;-b&#39;</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/manual_fitted_variogram.png"><img alt="../_images/manual_fitted_variogram.png" src="../_images/manual_fitted_variogram.png" style="width: 8in;" /></a>
<p>The <a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span> <span class="pre">Class</span></code></a> does in principle the
same thing. The only difference is that it tries to find a good
initial guess for the parameters and limits the search space for
parameters. That should make the fitting more robust.
Technically, we used the Levenberg-Marquardt algorithm above.
<a class="reference internal" href="../reference/variogram.html#skgstat.Variogram" title="skgstat.Variogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram</span></code></a> can be forced to use the same
by setting the <code class="xref py py-class docutils literal notranslate"><span class="pre">Variogram.fit_method</span></code>
to ‘lm’. The default, however, is ‘trf’, which is the <em>Trust Region Reflective</em>
algorithm, the bounded fit with initial guesses described above.
You can use it like:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [59]: </span><span class="n">V</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span><span class="s1">&#39;trf&#39;</span>

<span class="gp">In [60]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>

<span class="gp">In [61]: </span><span class="n">pprint</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">{&#39;effective_range&#39;: 36.78585313528298,</span>
<span class="go"> &#39;estimator&#39;: &#39;matheron&#39;,</span>
<span class="go"> &#39;name&#39;: &#39;spherical&#39;,</span>
<span class="go"> &#39;nugget&#39;: 0,</span>
<span class="go"> &#39;sill&#39;: 1.2473949087006804}</span>

<span class="gp">In [62]: </span><span class="n">V</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span><span class="s1">&#39;lm&#39;</span>

<span class="gp">In [63]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>

<span class="gp">In [64]: </span><span class="n">pprint</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">{&#39;effective_range&#39;: 36.78585313528298,</span>
<span class="go"> &#39;estimator&#39;: &#39;matheron&#39;,</span>
<span class="go"> &#39;name&#39;: &#39;spherical&#39;,</span>
<span class="go"> &#39;nugget&#39;: 0,</span>
<span class="go"> &#39;sill&#39;: 1.2473949087006804}</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/trf_automatic_fit.png"><img alt="../_images/trf_automatic_fit.png" src="../_images/trf_automatic_fit.png" style="width: 8in;" /></a>
<a class="reference internal image-reference" href="../_images/lm_automatic_fit.png"><img alt="../_images/lm_automatic_fit.png" src="../_images/lm_automatic_fit.png" style="width: 8in;" /></a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this example, the fitting method does not make a difference
at all. Generally, you can say that Levenberg-Marquardt is faster
and TRF is more robust.</p>
</div>
</div>
<div class="section" id="exponential-model">
<h4>Exponential model<a class="headerlink" href="#exponential-model" title="Permalink to this headline">¶</a></h4>
<p>The exponential model is quite similar to the spherical one.
It models semi-variance values to increase exponentially with
distance, like the spherical. The main difference is that this
increase is not as steep as for the spherical. That means, the
effective range is larger for an exponential model, that was
parameterized with the same range parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Remember that SciKit-GStat uses the <em>effective range</em>
to overcome this confusing behaviour.</p>
</div>
<p>Consequently, the exponential can be used for data that shows a way
too large spatial correlation extent for a spherical model to
capture.</p>
<p>Applied to the data used so far, you can see the similarity between
the two models:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [65]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="gp">In [66]: </span><span class="n">V</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="s1">&#39;trf&#39;</span>

<span class="gp">In [67]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gh">Out[67]: </span><span class="go">&lt;Figure size 800x400 with 2 Axes&gt;</span>

<span class="gp">In [68]: </span><span class="n">V</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="s1">&#39;exponential&#39;</span>

<span class="gp">In [69]: </span><span class="n">V</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hist</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/compare_spherical_exponential.png"><img alt="../_images/compare_spherical_exponential.png" src="../_images/compare_spherical_exponential.png" style="width: 8in;" /></a>
</div>
<div class="section" id="gaussian-model">
<h4>Gaussian model<a class="headerlink" href="#gaussian-model" title="Permalink to this headline">¶</a></h4>
<p>The last fundamental variogram model is the Gaussian.
Unlike the spherical and exponential models a very different
spatial relationship between semi-variance and distance.
Following the Gaussian model, observations are assumed to
be similar up to intermediate distances, showing just a
gentle increase in semi-variance. Then, the semi-variance
increases dramatically wihtin just a few distance units up
to the sill, which is again approached asymtotically.
The model can be used to simulate very sudden and sharp
changes in the variable at a specific distance,
while being very similar at smaller distances.</p>
<p>To show a typical Gaussian model, we will load another
sample dataset.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [70]: </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data/sample_lr.csv&#39;</span><span class="p">)</span>

<span class="gp">In [71]: </span><span class="n">Vg</span> <span class="o">=</span> <span class="n">Variogram</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">)),</span> <span class="n">data</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
<span class="gp">   ....: </span>    <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_lags</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [72]: </span><span class="n">Vg</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_data_gaussian_model.png"><img alt="../_images/sample_data_gaussian_model.png" src="../_images/sample_data_gaussian_model.png" style="width: 8in;" /></a>
</div>
<div class="section" id="matern-model">
<h4>Matérn model<a class="headerlink" href="#matern-model" title="Permalink to this headline">¶</a></h4>
<p>One of the not so commonly used models is the Matérn model.
It is nevertheless implemented into scikit-gstat as it is one
of the most powerful models. Especially in cases where you cannot
chose the appropiate model a priori so easily.
The Matérn model takes an additional smoothness paramter, that can
change the shape of the function in between an exponential
model shape and a Gaussian one.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [73]: </span><span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="go"># plot a exponential and a gaussian</span>
<span class="gp">In [74]: </span><span class="n">y_exp</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

<span class="gp">In [75]: </span><span class="n">y_gau</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>

<span class="gp">In [76]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="gp">In [77]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">y_exp</span><span class="p">,</span> <span class="s1">&#39;-b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;exponential&#39;</span><span class="p">)</span>
<span class="gh">Out[77]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7febf84dc8d0&gt;]</span>

<span class="gp">In [78]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">y_gau</span><span class="p">,</span> <span class="s1">&#39;-g&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">)</span>
<span class="gh">Out[78]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7febf89931d0&gt;]</span>

<span class="gp">In [79]: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">models</span><span class="o">.</span><span class="n">matern</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>
<span class="gp">   ....: </span>    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;--k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;matern s=</span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [80]: </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
<span class="gh">Out[80]: </span><span class="go">&lt;matplotlib.legend.Legend at 0x7febf89935c0&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/compare_smoothness_parameter_matern.png"><img alt="../_images/compare_smoothness_parameter_matern.png" src="../_images/compare_smoothness_parameter_matern.png" style="width: 8in;" /></a>
</div>
</div>
</div>
<div class="section" id="when-direction-matters">
<h2>When direction matters<a class="headerlink" href="#when-direction-matters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-direction">
<h3>What is ‘direction’?<a class="headerlink" href="#what-is-direction" title="Permalink to this headline">¶</a></h3>
<p>The classic approach to calculate a variogram is based on the
assumption that covariance between observations can be related to
their separating distance. For this, point pairs of all observation
points are formed and it is assumed that they can be formed without any restriction.
The only paramter to be influenced is a limiting distance, beyond which
a point pair does not make sense anymore.</p>
<p>This assumption might not always hold. Especially in landscapes, processes do
not occur randomly, but in an organized manner. This organization is often
directed, which can lead to stronger covariance in one direction than another.
Therefore, another step has to be introduced before lag classes are formed.</p>
<p>The <em>direction</em> of a variogram is then a orientation, which two points need.
If they are not oriented in the specified way, they will be ignored while calculating
a semi-variance value for a given lag class. Usually, you will specify a
orientation, which is called <a class="reference internal" href="../reference/directionalvariogram.html#id0" title="skgstat.DirectionalVariogram.azimuth"><code class="xref py py-func docutils literal notranslate"><span class="pre">azimuth</span></code></a>,
and a <a class="reference internal" href="../reference/directionalvariogram.html#id3" title="skgstat.DirectionalVariogram.tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">tolerance</span></code></a>, which is an
offset from the given azimuth, at which a point pair will still be accepted.</p>
</div>
<div class="section" id="defining-orientiation">
<h3>Defining orientiation<a class="headerlink" href="#defining-orientiation" title="Permalink to this headline">¶</a></h3>
<p>One has to decide how orientation of two points is determined. In scikit-gstat,
orientation between two observation points is only defined in <span class="math notranslate nohighlight">\(\mathbb{R}^2\)</span>.
We define the orientation as the <strong>angle between the vector connecting two observation points
with the x-axis</strong>.</p>
<p>Thus, also the <a class="reference internal" href="../reference/directionalvariogram.html#id0" title="skgstat.DirectionalVariogram.azimuth"><code class="xref py py-func docutils literal notranslate"><span class="pre">azimuth</span></code></a> is defined as an
angle of the azimutal vector to the x-axis, with an
<a class="reference internal" href="../reference/directionalvariogram.html#id3" title="skgstat.DirectionalVariogram.tolerance"><code class="xref py py-func docutils literal notranslate"><span class="pre">tolerance</span></code></a> in degrees added to the
exact azimutal orientation clockwise and counter clockwise.</p>
<p>The angle <span class="math notranslate nohighlight">\(\Phi\)</span> between two vetors <code class="docutils literal notranslate"><span class="pre">u,v</span></code> is given like:</p>
<div class="math notranslate nohighlight">
\[\Phi = cos^{-1}\left(\frac{u \circ v}{||u|| \cdot ||v||}\right)\]</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [81]: </span><span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">FancyArrowPatch</span> <span class="k">as</span> <span class="n">farrow</span>

<span class="gp">In [82]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

<span class="gp">In [83]: </span><span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gh">Out[83]: </span><span class="go">&lt;matplotlib.patches.FancyArrow at 0x7febf8788fd0&gt;</span>

<span class="gp">In [84]: </span><span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="o">-.</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gh">Out[84]: </span><span class="go">&lt;matplotlib.patches.FancyArrow at 0x7febf85046d8&gt;</span>

<span class="gp">In [85]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gh">Out[85]: </span><span class="go">(-0.1, 3.0)</span>

<span class="gp">In [86]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-.</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
<span class="gh">Out[86]: </span><span class="go">(-0.1, 2.0)</span>

<span class="gp">In [87]: </span><span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gh">Out[87]: </span><span class="go">&lt;matplotlib.collections.PathCollection at 0x7febf89cdda0&gt;</span>

<span class="gp">In [88]: </span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;A (0, 0)&#39;</span><span class="p">,</span> <span class="p">(</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">26</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="gh">Out[88]: </span><span class="go">Text(0.0, 0.26, &#39;A (0, 0)&#39;)</span>

<span class="gp">In [89]: </span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;B (2, 1)&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mf">2.05</span><span class="p">,</span><span class="mf">1.05</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="gh">Out[89]: </span><span class="go">Text(2.05, 1.05, &#39;B (2, 1)&#39;)</span>

<span class="gp">In [90]: </span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;Simple,head_width=6,head_length=12,tail_width=1&quot;</span>

<span class="gp">In [91]: </span><span class="n">ar</span> <span class="o">=</span> <span class="n">farrow</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">0.625</span><span class="p">],</span>  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3, rad=.2&quot;</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="n">arrowstyle</span><span class="p">)</span>

<span class="gp">In [92]: </span><span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
<span class="gh">Out[92]: </span><span class="go">&lt;matplotlib.patches.FancyArrowPatch at 0x7febf89cd9b0&gt;</span>

<span class="gp">In [93]: </span><span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;26.5°&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gh">Out[93]: </span><span class="go">Text(1.5, 0.25, &#39;26.5°&#39;)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_orientation_of_2_1.png"><img alt="../_images/sample_orientation_of_2_1.png" src="../_images/sample_orientation_of_2_1.png" style="width: 6in;" /></a>
<p>The described definition of orientation is illustrated in the figure above.
There are two observation points, <span class="math notranslate nohighlight">\(A (0,0)\)</span> and <span class="math notranslate nohighlight">\(B (2, 1)\)</span>. To decide
wether to account for them when calculating the semi-variance at their separating
distance lag, their orientation is used. Only if the direction of the varigram includes
this orientation, the points are used. Imagine the azimuth and tolerance would be
<code class="docutils literal notranslate"><span class="pre">45°</span></code>, then anything between <code class="docutils literal notranslate"><span class="pre">0°</span></code> (East) and <code class="docutils literal notranslate"><span class="pre">90°</span></code> orientation would be included.
The given example shows the orientation angle <span class="math notranslate nohighlight">\(\Phi = 26.5°\)</span>, which means the
vector <span class="math notranslate nohighlight">\(\overrightarrow{AB}\)</span> is included.</p>
</div>
<div class="section" id="calculating-orientations">
<h3>Calculating orientations<a class="headerlink" href="#calculating-orientations" title="Permalink to this headline">¶</a></h3>
<p>SciKit-GStat implements a slightly adaped version of the formula given in the
last section. It makes use of symmetric search areas (tolerance is applied clockwise
and counter clockwise) und therefore any calculated angle might be the result
of calculating the orientation of <span class="math notranslate nohighlight">\(\overrightarrow{AB}\)</span> or
<span class="math notranslate nohighlight">\(\overrightarrow{BA}\)</span>. Mathematically, these two vectors have two different
angles, but they are always both taken into account or omitted for a variagram
at the same time. Thus, it does not make a difference for variography.
However, it does make a difference when you try to use the orientation angles
directly as the containing matrix can contain the inverse angles.</p>
<p>This can be demonstrated by an easy example. Let <code class="docutils literal notranslate"><span class="pre">c</span></code> be a set of points mirrored
along the x-axis.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [94]: </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>

<span class="gp">In [95]: </span><span class="n">east</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>We can plug these two arrays into the the formula above:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [96]: </span><span class="n">u</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>   <span class="c1"># omit the first one</span>

<span class="gp">In [97]: </span><span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">east</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))))</span>

<span class="gp">In [98]: </span><span class="n">angles</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gh">Out[98]: </span><span class="go">array([26.6, 63.4, 26.6, 63.4])</span>
</pre></div>
</div>
<p>You can see, that the both points and their mirrored counterpart have the same
angle to the x-axis, just like expected. This can be visualized by the plot below:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [99]: </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

<span class="gp">In [100]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-.</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.25</span><span class="p">)</span>
<span class="gh">Out[100]: </span><span class="go">(-0.1, 2.25)</span>

<span class="gp">In [101]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span><span class="mf">2.1</span><span class="p">)</span>
<span class="gh">Out[101]: </span><span class="go">(-2.1, 2.1)</span>

<span class="gp">In [102]: </span><span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="o">-.</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">3.1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="gh">Out[102]: </span><span class="go">&lt;matplotlib.patches.FancyArrow at 0x7febf83b0e80&gt;</span>

<span class="gp">In [103]: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
<span class="gp">   .....: </span>    <span class="n">ax</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.1f</span><span class="s1">°&#39;</span> <span class="o">%</span> <span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">   .....: </span>

<span class="gp">In [104]: </span><span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gh">Out[104]: </span><span class="go">&lt;matplotlib.collections.PathCollection at 0x7febf83a8908&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_orientation_of_multiple_points.png"><img alt="../_images/sample_orientation_of_multiple_points.png" src="../_images/sample_orientation_of_multiple_points.png" style="width: 6in;" /></a>
<p>The main difference to the internal structure storing the orientation angles for a
<a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram" title="skgstat.DirectionalVariogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirectionalVariogram</span></code></a> instance will store different
angles.
To use the class on only five points, we need to prevent the class from fitting, as
fitting on only 5 points will not work. But this does not affect the orientation calculations.
Therefore, the <code class="xref py py-func docutils literal notranslate"><span class="pre">fit</span></code> mehtod is overwritten.</p>
<p>The first two points (with positive y-coordinate) show the same result. The other two,
with negative y-coordinates, are also calculated counter clockwise:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [105]: </span><span class="mi">360</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">DV</span><span class="o">.</span><span class="n">_angles</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="gh">Out[105]: </span><span class="go">array([216.044, 100.421])</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../reference/directionalvariogram.html#skgstat.DirectionalVariogram" title="skgstat.DirectionalVariogram"><code class="xref py py-class docutils literal notranslate"><span class="pre">DirectionalVariogram</span></code></a> class has a plotting
function to show a network graph of all point pairs that are oriented in the
variogram direction. But first we need to increase the tolerance as half tolerance
(<code class="docutils literal notranslate"><span class="pre">45°</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">22.5°</span></code> clockwise and counter clockwise) is smaller than both orientations.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [106]: </span><span class="n">DV</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="mi">90</span>

<span class="gp">In [107]: </span><span class="n">DV</span><span class="o">.</span><span class="n">pair_field</span><span class="p">()</span>
<span class="gh">Out[107]: </span><span class="go">&lt;Figure size 800x800 with 1 Axes&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/sample_pair_field_plot.png"><img alt="../_images/sample_pair_field_plot.png" src="../_images/sample_pair_field_plot.png" style="width: 8in;" /></a>
</div>
<div class="section" id="directional-variogram">
<h3>Directional variogram<a class="headerlink" href="#directional-variogram" title="Permalink to this headline">¶</a></h3>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [108]: </span><span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;data/aniso_x2.txt&#39;</span><span class="p">)</span>

<span class="gp">In [109]: </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1312</span><span class="p">)</span>

<span class="gp">In [110]: </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

<span class="gp">In [111]: </span><span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span><span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
</pre></div>
</div>
<p>The next step is to create two different variogram instances, which share the same
parameters, but use a different azimuth angle. One oriented to North and the
second one oriented to East.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [112]: </span><span class="n">Vnorth</span> <span class="o">=</span> <span class="n">DirectionalVariogram</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">azimuth</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">n_lags</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">In [113]: </span><span class="n">Veast</span> <span class="o">=</span> <span class="n">DirectionalVariogram</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">azimuth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">n_lags</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="gp">In [114]: </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;north&#39;</span><span class="p">:</span><span class="n">Vnorth</span><span class="o">.</span><span class="n">describe</span><span class="p">(),</span> <span class="s1">&#39;east&#39;</span><span class="p">:</span> <span class="n">Veast</span><span class="o">.</span><span class="n">describe</span><span class="p">()})</span>
<span class="gh">Out[114]: </span><span class="go"></span>
<span class="go">                     north       east</span>
<span class="go">name             spherical  spherical</span>
<span class="go">estimator         matheron   matheron</span>
<span class="go">effective_range         80    36.6635</span>
<span class="go">sill                 1.483   0.808277</span>
<span class="go">nugget                   0          0</span>
</pre></div>
</div>
<p>You can see, how the two are differing in effective range and also sill, only
caused by the orientation. Let’s look at the experimental variogram:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [115]: </span><span class="n">fix</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="gp">In [116]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Vnorth</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span> <span class="n">Vnorth</span><span class="o">.</span><span class="n">experimental</span><span class="p">,</span> <span class="s1">&#39;.--r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;North-South&#39;</span><span class="p">)</span>
<span class="gh">Out[116]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7febfc44e2b0&gt;]</span>

<span class="gp">In [117]: </span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Veast</span><span class="o">.</span><span class="n">bins</span><span class="p">,</span> <span class="n">Veast</span><span class="o">.</span><span class="n">experimental</span><span class="p">,</span> <span class="s1">&#39;.--b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;East-West&#39;</span><span class="p">)</span>
<span class="gh">Out[117]: </span><span class="go">[&lt;matplotlib.lines.Line2D at 0x7febfc44e748&gt;]</span>

<span class="gp">In [118]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;lag [m]&#39;</span><span class="p">)</span>
<span class="gh">Out[118]: </span><span class="go">Text(0.5, 0, &#39;lag [m]&#39;)</span>

<span class="gp">In [119]: </span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;semi-variance (matheron)&#39;</span><span class="p">)</span>
<span class="gh">Out[119]: </span><span class="go">Text(0, 0.5, &#39;semi-variance (matheron)&#39;)</span>

<span class="gp">In [120]: </span><span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
<span class="gh">Out[120]: </span><span class="go">&lt;matplotlib.legend.Legend at 0x7fec046abf98&gt;</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/expermiental_direcional_varigram_comparison.png"><img alt="../_images/expermiental_direcional_varigram_comparison.png" src="../_images/expermiental_direcional_varigram_comparison.png" style="width: 8in;" /></a>
<p>The shape of both experimental variograms is very similar on the first 40 meters
of distance. Within this range, the apparent anisotropy is not pronounced.
The East-West oriented variograms also have an effective range of only about 40 meters,
which means that in this direction the observations become statistically independent
at larger distances.
For the North-South variogram the effective range is way bigger and the variogram
plot reveals much larger correlation lengths in that direction. The spatial
dependency is thus directed in North-South direction.</p>
<p>To perform Kriging, you would now transform the data, especially in North-West
direction, unitl both variograms look the same within the effective range.
Finally, the Kriging result is back-transformed into the original coordinate system.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">SciKit GStat</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=mmaelicke&repo=scikit-gstat&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="userguide.html">User Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Variography</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-variogram">The variogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="#when-direction-matters">When direction matters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="kriging.html">Interpolation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../technical/technical.html">Technical Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/reference.html">Code Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://mmaelicke.github.io/scikit-gstat/SciKitGStat.pdf">Download PDF</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="userguide.html">User Guide</a><ul>
      <li>Previous: <a href="introduction.html" title="previous chapter">Introduction</a></li>
      <li>Next: <a href="kriging.html" title="next chapter">Interpolation</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Mirko Mälicke.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.4.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/userguide/variogram.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>